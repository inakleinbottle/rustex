use std::ffi::OsString;
use std::path::{Path, PathBuf};
use std::process::{Command, Stdio};
use std::slice::Iter;
use std::sync::Arc;
use std::fmt::Display;

use failure::{err_msg, Error as E};
use indicatif::ProgressBar;
use structopt::StructOpt;

use outparse::{BuildReport, Message};

use crate::config::Config;
use crate::jobs::Job;
use crate::report::RunnerReport;
use crate::runner::{Runner};


/// LaTeX file build utility.
///
/// This is essentially a wrapper around the LaTeX executables
/// that adds intelligent building and simplified build reports.
/// Also supports running auxiliary programs such as BibTeX,
/// Biber, and Makeindex. The builder will generate an appropriate
/// build order for in this case.
///
/// The builder supports multiple input file build jobs, and the
/// jobs are executed asyncronously, by making non-blocking calls
/// to the underlying LaTeX engine.
#[derive(StructOpt)]
pub struct CliOptions {
    #[structopt(flatten)]
    pub config: Config,

    /*
    /// Maximum number of build attempts.
    ///
    /// Maximum number of attempts to build the document
    /// and remove any warnings generated by unresolved
    /// references. Default value: 2.
    #[structopt(long="max-rebuilds", default_value="2")]
    max_rebuilds: u8,
    */

    /*
    /// Force LaTeX engine to execute twice.
    ///
    /// This does not apply if the build fails
    /// due to an error.
    #[structopt(long="force-two-runs")]
    force_two_builds: bool,
    */
    /// Files to build
    ///
    /// THe files to attempt to build in this run of
    /// LaTeX.
    #[structopt(name = "files", parse(from_os_str))]
    pub files: Vec<PathBuf>,
}

impl Default for CliOptions {
    fn default() -> CliOptions {
        CliOptions {
            config: Config::default(),
            files: Vec::new(),
        }
    }
}

pub fn run() -> Result<(), E> {
    let CliOptions { config, files } = CliOptions::from_args();
    let conf = Arc::new(config);

    // do the setup for verbosity etc.
    let mut runner = Runner::new(conf.clone(),  
                                 &files);
    let pb = ProgressBar::new(files.len() as u64);
    
    while let Some(completed) = runner.process_till_next_complete() {
        pb.tick();
        pb.println(completed.to_string());
    }
    runner.do_cleanup()?;

    let report = runner.build_report()?;
    pb.println(report.to_string());
    pb.finish_and_clear();
    
    Ok(())
}
