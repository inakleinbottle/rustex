use std::path::{Path,PathBuf};
use std::ffi::OsString;
use std::process::{Command, Stdio};
use std::slice::Iter;

use failure::{Error as E, err_msg};
use structopt::StructOpt;

use crate::runner::{Runner};
use crate::config::Config;




#[derive(StructOpt)]
struct LatexRunnerConfig {

    /// LaTeX executable to use. (The build engine.)
    /// 
    /// Must be an executable on PATH. Default="pdflatex"
    #[structopt(long="engine", default_value="pdflatex")]
    engine: String,
    
    /// LaTeX flags to use.
    /// 
    /// Multiple calls add more flags.
    #[structopt(long="latex-flag")]
    flags: Vec<String>,

    /// Directory in which the build occurs.
    /// 
    /// Specify a different directory for the output of the
    /// LaTeX build process.
    #[structopt(long="build-dir", parse(from_os_str))]
    build_directory: Option<OsString>,

    /// Clean build directory after build.
    /// 
    /// If selected, the auxiliary files, log files, and
    /// other output files (excluding the output of LaTeX)
    /// will be removed from the build directory. Unless
    /// a second build is forced, a second build run will
    /// only be executed if there are unresolved warnings.
    #[structopt(long="clean")]
    clean_build: bool,

    /// Maximum number of build attempts.
    /// 
    /// Maximum number of attempts to build the document
    /// and remove any warnings generated by unresolved 
    /// references. Default value: 2.
    #[structopt(long="max-rebuilds", default_value="2")]
    max_rebuilds: u8,

    /// Force LaTeX engine to execute twice.
    /// 
    /// This does not apply if the build fails
    /// due to an error.
    #[structopt(long="force-two-runs")]
    force_two_builds: bool,

    /// Files to build
    /// 
    /// THe files to attempt to build in this run of 
    /// LaTeX.
    #[structopt(name="files", parse(from_os_str))]
    files: Vec<PathBuf>,

}

impl Default for LatexRunnerConfig {
    fn default() -> LatexRunnerConfig {
        LatexRunnerConfig {
            engine: String::from("pdflatex"),
            flags: vec![String::from("-interaction=nonstopmode")],
            build_directory: None,
            max_rebuilds: 1,
            force_two_builds: false,
            clean_build: false,
            files: Vec::new()
        }
    }
}

impl LatexRunnerConfig {

    pub fn get_command(&self) -> Command {
        let mut cmd = Command::new(&self.engine);
        for f in &self.flags {
            cmd.arg(f);
        }
        if let Some(ref p) = self.build_directory {
            let mut flag = OsString::from("-output-directory=");
            flag.push(p.as_os_str());
            cmd.arg(&flag);
        }
        cmd.stdout(Stdio::piped());
        cmd.stderr(Stdio::inherit());
        cmd
    }
}


/// LaTeX file build utility.
/// 
/// This is essentially a wrapper around the LaTeX executables
/// that adds intelligent building and simplified build reports.
/// Also supports running auxiliary programs such as BibTeX, 
/// Biber, and Makeindex. The builder will generate an appropriate
/// build order for in this case.
/// 
/// The builder supports multiple input file build jobs, and the
/// jobs are executed asyncronously, by making non-blocking calls
/// to the underlying LaTeX engine.
#[derive(StructOpt)]
pub struct CliOptions{


    /// Use verbose mode.Vec
    /// 
    /// More output will be generated during the build 
    #[structopt(short="v", long="verbose")]
    pub verbose: bool,

    #[structopt(flatten)]
    latex_config: LatexRunnerConfig,

}

impl Default for CliOptions {
    fn default() -> CliOptions {
        CliOptions {
            verbose: false,
            latex_config: LatexRunnerConfig::default()
        }
    }
}


impl CliOptions {

    pub fn paths(&self) -> Iter<PathBuf> {
        self.latex_config.files.iter()
    }

    pub fn get_command(&self) -> Command {
        self.latex_config.get_command()
    }
}



pub fn run() -> Result<(), E> {
    let args = CliOptions::from_args();
    let config = Config::new(args);
    

    // do the setup for verbosity etc.
    let mut runner = Runner::new(&config);

    let report = runner.run()?;
    println!("{}", report);
    Ok(())
}